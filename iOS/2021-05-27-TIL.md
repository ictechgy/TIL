# 2021-05-27-TIL

날짜: May 27, 2021
작성자: 🐶 Coden
태그: CS, Git, Naming, PR, PairProgramming, 과제코드리뷰

# 🖥 TIL (Today I Leared)

2021년 5월 27일 목요일

## 학습내용

오늘은 CS 기초에 대해서 다시 공부하였다. 예전에 조금 공부를 하긴 했었지만 많이 까먹었었기에, 처음부터 다시 공부하는 느낌이었다. (잘못 기억하고 있던 내용들도 바로 잡을 수 있었다.)

프로젝트도 하나 수행하였는데 다른 사람을 통해서 내가 이전에 생각하지 못했었던 것들을 많이 배울 수 있었다. 

(내가 생각했던 프로그램 로직과 다른 사람이 생각한 프로그램 로직을 비교하면서 뭐가 더 나은지 토의하고 이야기하는 일련의 과정들을 통하여)

&nbsp;

## 앨런 튜링(Alan Mathison Turing)

알고리즘과 계산 개념을 튜링 기계라는 추상모델을 통해 형식화함으로써 컴퓨터 과학의 발전에 지대한 공헌을 했다. 튜링테스트를 고안한 것으로도 유명하다.

튜링 머신은 현대 컴퓨터의 초안이 된 기계로서 긴 테이프에 쓰여있는 여러 가지 기호들을 일정한 규칙에 따라 바꾸는 기계를 의미한다. 

튜링 테스트는 인간과 동등하거나 구별할 수 없는 지능적인 행동을 보여주는 기계의 능력에 대한 테스트를 말한다.

> [앨런튜링 - 위키백과](https://ko.wikipedia.org/wiki/앨런_튜링)

> [튜링머신](https://norman3.github.io/papers/docs/neural_turing_machine.html)

> [튜링테스트 - 위키백과](https://ko.wikipedia.org/wiki/%ED%8A%9C%EB%A7%81_%ED%85%8C%EC%8A%A4%ED%8A%B8)

&nbsp;

## 컴퓨터의 역사

최초의 다용도 컴퓨터: ENIAC

최초의 실용적 프로그램 내장 전자식 컴퓨터: EDSAC

폰노이만의 설계를 반영하여 탄생한 최초의 2진수 컴퓨터: EDVAC (이전까지는 10진수를 썼었다.)

1세대 컴퓨터 - 부피가 굉장히 컸으며 진공관을 이용하였다. 기억장치로는 자기 드럼을 이용하였다. 진공관 자체가 열과 빛이 많았기 때문에 벌레가 자주 꼬였는데 이 벌레에서 프로그래밍 bug가 유래되었다는 이야기가 있다.

2세대 컴퓨터 - 기억 소자로 트랜지스터를 이용하였다.

3세대 컴퓨터 - 집적회로(IC)를 이용하였다. 기기의 소형화가 가능해졌다.

&nbsp;

## 컴퓨터의 기본 구성요소

컴퓨터는 크게 하드웨어와 소프트웨어로 구성되어있다. 

- 하드웨어

    구성요소로는 입력 및 출력장치, 기억장치(주기억과 보조기억), 중앙처리장치(CPU라고 하며 제어장치, 산술논리연산장치, 레지스터가 내부에 있다.)가 있다.

- 소프트웨어

    크게 시스템 소프트웨어와 응용 소프트웨어로 나누어지는데 시스템 소프트웨어에는 OS, 로더, 컴파일러 등이 있다. 응용 소프트웨어는 우리가 쓰는 애플리케이션들(워드, Xcode 등)을 지칭한다.

    응용소프트웨어들은 모두 OS위에서 동작한다.

&nbsp;

## 컴퓨터의 구조

- 하버드 구조

명령어 메모리와 데이터 메모리가 분리되어있는 형태로 속도는 빠르지만 비용이 비싸고 구조가 복잡하다.

- 폰 노이만 구조

명령어 메모리와 데이터 메모리가 분리되어있지 않고 하나로 이루어져 있다. 메모리와 데이터를 주고받는 것은 하나의 버스를 이용한다. (버스에는 데이터 버스, 주소버스, 제어버스가 있다.)

→ 우리가 지금 쓰고 있는 컴퓨터들은 하버드 구조와 폰 노이만 구조를 동시에 가지고 있다. CPU 내부는 하버드 구조를 이루고 있으며 캐시를 이용한다. CPU 외부는 폰노이만 구조를 가지고 있다.

&nbsp;

## 32bit와 64bit

CPU가 한번에 처리할 수 있는 0과 1의 개수를 의미한다. (정확히 말하자면 레지스터가 처리할 수 있는 최대 bit를 의미한다. 워드라고도 한다.) 

- 왜 32bit 아키텍쳐는 램을 4GB까지만 지원하는가?

    레지스터가 32비트까지만 담을 수 있다는 것은 주소값을 담는 PC레지스터(Program Counter)도 32비트라는 것이고 이는 접근할 수 있는 주소의 범위가 2^32까지라는 것을 의미한다. 때문에 2^32의 크기로는 최대 4GB까지밖에 접근하지 못한다.(1GB는 2^30이고 4는 2^2이므로 4GB는 2^32이다.)

&nbsp;

## IPv4와 IPv6

- IPv4

    32bit로 이루어져 있으며 우리는 읽을 때 8자리씩 끊어 10진수로 읽는다. ex) 127.0.0.1 - loopback

    약 43억개까지 사용 가능하나 IoT기기등의 출현으로 주소값이 모자르게 되었다.

    예전에는 Class를 나누어 사용하였으나 요즘은 Classless하게 사용한다.(Class를 나누는 경우 낭비가 심했음)

- IPv6(128bit)

    128bit로 이루어져 있으며 IPv4의 주소값 고갈문제를 해결하기 위한 프로토콜로써 제안되었다. 

    16bit단위로 끊은 뒤 4자리씩 16진수로 표현한다. 

&nbsp;

## 컴퓨터의 데이터 표현 방식

컴퓨터는 데이터를 2진수로 표현하며 데이터 표현의 최소단위는 bit이다.

- 모든 숫자값은 2진수로 바꾸어 처리하는데 음수의 경우 2의 보수법을 사용한다.
- 실수는 부동소수점 방식을 사용하며 부호비트, 지수부, 가수부를 나누어 처리한다. 널리 사용하는 표준으로는 IEEE 754가 있다.
- 문자를 표현하는 방식은 여러가지가 있다. ASCII, UNICODE, UTF-8 등..

&nbsp;

## 유니코드란?

전 세계의 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계된 산업 표준이며, 유니코드 협회(Unicode Consortium)가 제정한다. 유니코드의 목적은 현존하는 문자 인코딩 방법들을 모두 유니코드로 교체하려는 것이다.

> [유니코드 - 위키백과](https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C)

&nbsp;

## 컴퓨터의 연산

컴퓨터는 덧셈만 가능하다. 뺄셈은 2의 보수법을 이용하여 덧셈으로 처리하고, 곱셈은 덧셈을 반복, 나눗셈은 뺄셈을 반복하여 처리한다.

논리회로적으로 보면 반가산기(Half Adder) 하나가 이진수 한자리수 연산을 처리한다.

![https://user-images.githubusercontent.com/39452092/119877871-8392c180-bf64-11eb-85d5-cf10cb922b08.png](https://user-images.githubusercontent.com/39452092/119877871-8392c180-bf64-11eb-85d5-cf10cb922b08.png)

> [출처: 위키백과 - 가산기](https://ko.wikipedia.org/wiki/%EA%B0%80%EC%82%B0%EA%B8%B0)

XOR 하나와 AND 하나로 구성되어있다. S는 Sum, C는 Carry를 의미한다.

&nbsp;

## 프로그래밍과 코딩은 다른가?

다르다. 프로그래밍이 조금 더 넓은 범위라고 보면 된다.

- 코딩은 알고리즘을 선정한 프로그래밍 언어의 명령으로 변환하여 작성하는 것이다. 기본적으로 한 언어에서 다른 언어로 코드를 만드는 과정이다. 프로그래밍의 초기 단계를 구현하는 데 사용되기 때문에 프로그래밍의 하위 집합이라고도 할 수 있다.

    기계는 인간의 자연어를 이해하지 못하고 이진 언어인 기계코드만 이해한다. 그래서 코더(coder)는 요구 사항을 기계가 이해할 수 있는 언어로 변환하는 역할을 한다. 코더는 논리를 기계가 읽을 수 있는 코드로 변환하는 언어 지향 프로그래머이다.

- 프로그래밍은 컴퓨터에 부여하는 명령을 만드는 작업한다. 실행 가능한 기계 또는 응용 프로그램을 개발하는 과정이다.

    프로그래밍은 단순히 코드를 작성하는 것 이상을 포함한다. 코드 작성, 분석 및 구현, 기계 레벨 출력 생성, 디버깅, 컴파일, 테스트 및 구현 등 원하는 출력을 만들기 위한 모든 중요한 영역을 포함한다. 보통 개인이 프로그래머가 되기 위해서는 코더가 되는 것보다 훨씬 더 많은 시간이 필요하다.

> [출처 - 코딩월드뉴스](http://www.codingworldnews.com/news/articleView.html?idxno=1132)

&nbsp;

## 주 기억장치는 왜 주 기억장치라고 불리는가?

폰 노이만 구조에 있어서 보조 기억장치라고 별도로 두는 것은 없다. 또, 기본적으로 주 기억장치는 컴퓨터에 있어서 필수적이다. 보조기억장치에 있는 데이터가 주 기억장치에 있다면 그 순간에는 보조기억장치가 없어도 컴퓨터는 동작할 수 있다. 즉 주 기억장치가 더 주요(Primary)하다고 볼 수 있다.

&nbsp;

## 프로그램과 프로세스의 차이

프로그램(Program)은 파일시스템에 존재하는 실행파일을 의미한다. 

프로세스(Process)는 주 기억장치에 올라가서 실행중인 프로그램을 의미하며 일반적으로 프로세서(Processor)에 의해 처리된다.

&nbsp;

## 컨버팅과 인코딩

- 컨버팅

    개발된 프로그램을 같은 플랫폼 내에서 언어만 바꾸어 동작하게 하는 것. 

    (다른 플랫폼에서 동작할 수 있도록 이식 하는 것은 포팅이라고 한다.)

- 인코딩

    부호화(符號化) 또는 인코딩(encoding)은 컴퓨터를 이용해 영상 · 이미지 · 소리 데이터를 생성할 때 데이터의 양을 줄이기 위해 데이터를 코드화하고 압축하는 것이다. 정보의 형태나 형식을 표준화, 보안, 처리 속도 향상, 저장 공간 절약 등을 위해서 다른 형태나 형식으로 변환하는 것이다.

    > [위키백과 - 부호화](https://ko.wikipedia.org/wiki/%EB%B6%80%ED%98%B8%ED%99%94)

크게 보면 컨버팅이 인코딩보다 넓은 개념으로 볼 수도 있을 것 같다.

인코딩은 정보를 컴퓨터가 알아들을 수 있게 컨버팅 하는 과정이라고 볼 수도 있을 것 같고.. 

파일의 포맷 변경도 컨버팅이라고 한다.

&nbsp;

## 인코딩이 필요한 이유

컴퓨터는 음악, 영상, 사진, 문자 등 아날로그 데이터들을 있는 그대로 이해할 수 없으므로 이를 숫자(디지털 데이터)로 변환해주어야 한다. 따라서 인코딩이 필요하다. (이 인코딩 된 데이터들은 통신을 통해 다른 사람에게 전달 될 수 있고 상대방은 디코딩 과정을 통해 다시 아날로그 데이터로 정보를 볼 수 있게 된다.)

인코딩 하는데에 몇개의 비트를 쓰느냐에 따라 품질과 용량이 달라지게 된다. (표본화 양자화 부호화 - 소리 인코딩)

&nbsp;

## 컴퓨터는 왜 0과 1로 표현하는가?

컴퓨터는 전기신호를 이용하는데 이 전기라는 것은 사실 잡음이 섞일 수도 있는 아날로그 신호이다. 

만약 0과 1이 아닌 연속적인 전기 신호를 사용한다면 2진법이 아닌 그 이상의 진법도 사용할 수 있겠지만, 잡음이 섞일 수 있다는 특징때문에 특정 레벨의 전기 신호가 어떤 값을 의미하는지 장담할 수 없게 된다.

따라서 신호 처리를 확실하게 하기 전기 신호가 있거나 / 없는 양 극단의 값 만을 사용하게 되었다. 이산적인 신호(디지털 신호)로써 말이다.

→ 양자컴퓨터의 경우 0과 1의 상태를 동시에 갖는 큐비트를 기본단위로 처리한다.

&nbsp;

## 망중립이란?

망 중립성(網 中立性, 영어: net neutrality)은 모든 네트워크 사업자와 정부들은 인터넷에 존재하는 모든 데이터를 동등하게 취급하고, 사용자, 내용, 플랫폼, 장비, 전송 방식에 따른 어떠한 차별도 하지 않아야 한다는 뜻이다. 이 용어는 2003년에 컬럼비아 대학교의 미디어 법 교수인 팀 우(Tim Wu)가 만들었다. 비차별, 상호접속, 접근성 등 3가지 원칙이 동일하게 적용되어야 하는 것이 조건이다.

> [위키백과 - 망중립](https://ko.wikipedia.org/wiki/%EB%A7%9D_%EC%A4%91%EB%A6%BD%EC%84%B1)

### 이 용어가 이슈가 된 이유?

우리나라에서는 넷플릭스-SK 브로드밴드간의 갈등으로 유명하다. SK 브로드밴드가 넷플릭스에게 통신망 사용료를 내라고 요구하면서 시작되었다.

&nbsp;

## 프로젝트를 진행하면서 배운점, 느낀점

프로젝트를 진행하면서 배우고 느꼈던 점은

1. Naming이 정말 어렵다는것

    네이밍은 너무 어려웠다. 함수명도 그렇고 변수명도 그렇고.. 파라미터명과 인자레이블까지..

2. 함수의 기능별 분리

    특정 함수가 어떤 기능을 하게 할 것인지 미리 명확하게 정해두고 하는 것이 좋을 것 같다. (나중에 분리하는 것 보다는)

3. 코드를 작성하면서 설계와는 조금 다르게 작성됐던 것

    초반 설계를 조금 더 꼼꼼하게 해야하는 것일까..?